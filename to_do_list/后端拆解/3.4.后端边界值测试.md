# 边界值测试 (step2_4_boundary.py)

切换至script engineer模式
- [ ] 创建 step2_4_boundary.py
Python 逻辑示例
```python
import sys

def run_smart_boundary(base_url, token, api_config):
    url = f"{base_url}{api_config['path']}"
    method = api_config['method']
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    base_payload = api_config.get('payload', {})
    
    # 跳过非 JSON 请求 (如文件上传)
    if api_config.get('content_type') != 'application/json' or not base_payload:
        return []

    boundary_results = []
    
    # 遍历 Payload 中的每个字段
    for key, value in base_payload.items():
        boundaries = []
        
        # A. 针对整型的边界
        if isinstance(value, int):
            boundaries = [
                (2147483647, "MaxInt"), 
                (-2147483648, "MinInt"), 
                (0, "Zero")
            ]
        # B. 针对字符串的边界
        elif isinstance(value, str):
            boundaries = [
                ("", "EmptyString"), 
                ("A" * 5000, "OverFlowString"), # 5000字长测试缓冲区溢出或DB字段限制
                (None, "NullValue") # 测试后端 @NotNull 校验
            ]
            
        # 执行测试
        for val, desc in boundaries:
            # 浅拷贝构造新载荷
            test_payload = base_payload.copy()
            test_payload[key] = val
            
            try:
                resp = requests.request(method, url, headers=headers, json=test_payload)
                # 我们只关心 500 (系统未处理异常)
                # 400 (Bad Request) 是预期行为，代表边界被拦截成功
                if resp.status_code == 500:
                    boundary_results.append({
                        "field": key,
                        "value_desc": desc,
                        "code": 500,
                        "msg": "边界值导致系统崩溃"
                    })
            except Exception:
                pass
                
    return boundary_results
```


- [ ] 精确边界模拟：根据 apis.json 中标识的参数类型（如 int, string），生成该类型特有的边界值（如 2147483647 或空数组）。

- [ ] 类型推断 (Type Inference): 遍历 apis.json 中的 payload。

   - 若字段值为 int (如 "id": 1) -> 测试 2147483647 (MaxInt), -2147483648, 0。

   - 若字段值为 str (如 "name": "test") -> 测试 "" (空串), "A"*1024 (超长), null。

   - 若字段值为 list -> 测试 [], [elements]*1000。

- [ ] 单一变量原则 (Control Variable): 每次只修改一个字段为边界值，保持其他字段为合法默认值。这能确保如果有 500 报错，一定是由当前测试的那个边界值引起的，而不是其他参数格式错误。

## 输出：写入 {work_dir}/results_boundary.json。

切换至debugger模式
- [ ] 流程自检：若认证凭据比如token失效，则需要通过运行前置token获取脚本重新获取

- [ ] 数据审查：检查测试过程中是否因载荷格式错误导致过多的 JSON_PARSE_FAIL，优化载荷生成逻辑。

- [ ] 脱敏处理：确保日志中所有 Token 均替换为 <REDACTED>。
# 边界值测试 (step2_4_boundary.py)

切换至script engineer模式
- [ ] 创建 step2_4_boundary.py

## Python 核心逻辑示例
```python
import requests, sys, re, random, json

# 辅助函数：动态填充路径参数
def fill_path_params(url, id_pool):
    matches = re.findall(r'\{(.*?)\}', url)
    for param in matches:
        valid_values = []
        for k, v in id_pool.items():
            if param.lower() in k.lower():
                valid_values = v
                break
        
        if valid_values:
            val = random.choice(valid_values)
            url = url.replace(f"{{{param}}}", str(val))
        else:
            url = url.replace(f"{{{param}}}", "1")
    return url

def run_smart_boundary(base_url, token, api_list):
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}
    boundary_results = []
    
    # 1. 提取全局 ID 池
    global_id_pool = {}
    for api in api_list:
        if 'id_pool' in api and api['id_pool']: 
            global_id_pool.update(api['id_pool'])

    for api in api_list:
        method = api['method']
        # 跳过非 JSON 请求
        if api.get('content_type') != 'application/json': continue
        
        # 2. 准备环境 & 路径填充
        raw_url = f"{base_url}{api['path']}"
        url = fill_path_params(raw_url, global_id_pool)
        
        # 3. Admin Shield: PUT/DELETE 跳过敏感 ID
        if method in ['PUT', 'DELETE']:
            if any(x in url for x in ['/1', '/0', '/admin']): continue

        # 4. 获取基准载荷 (Smart Seed)
        base_payload = api.get('smart_payload', {})
        if not base_payload: continue

        # 5. 执行边界测试 (单一变量原则)
        for key, value in base_payload.items():
            boundaries = []
            if isinstance(value, int):
                boundaries = [(2147483647, "MaxInt"), (-2147483648, "MinInt"), (0, "Zero")]
            elif isinstance(value, str):
                boundaries = [("", "Empty"), ("A"*5000, "Overflow"), (None, "Null")]
            
            for val, desc in boundaries:
                # 构造 Payload：只改一个字段，其他字段保持基准值
                test_payload = base_payload.copy()
                test_payload[key] = val
                
                try:
                    resp = requests.request(method, url, headers=headers, json=test_payload)
                    # 关注 500 系统崩溃
                    if resp.status_code == 500:
                        boundary_results.append({
                            "path": api['path'],
                            "field": key,
                            "desc": desc,
                            "code": 500,
                            "msg": "边界值测试导致500错误"
                        })
                except: pass
                
    return boundary_results
```

## 核心逻辑：
- 数据源准备：读取 apis.json 中的 smart_payload 作为基准载荷。

- 保护性前置检查 (Admin Shield)：对于 PUT 或 DELETE 接口，若填充后的 URL 指向管理员 ID，直接跳过测试。

- 单一变量原则：每次只修改一个字段为边界值，保持其余字段为 smart_payload 中的合法默认值（这些值来自真实挖掘的数据）。

- 预期结果：忽略 400 (Bad Request)，重点捕获 500 (Internal Server Error)。

- 输出：写入 {work_dir}/results_boundary.json。
## 切换至debugger模式

- [ ] 流程自检：Token 失效重连、日志脱敏。
# 健壮性模糊测试 (step2_3_fuzz.py)
切换至script engineer模式
- [ ] 创建 step2_3_fuzz.py
   - Python 逻辑示例
```python
   def run_polymorphic_fuzz(base_url, token, api_config):
    # 1. 基础设置
    url = f"{base_url}{api_config['path']}"
    method = api_config['method']
    headers = {"Authorization": f"Bearer {token}"}
    base_payload = api_config.get('payload', {})
    
    fuzz_results = []
    
    # 2. 针对文件上传的 Fuzz 策略
    if api_config.get('content_type') == 'multipart/form-data':
        vectors = [
            ("Malicious_Ext", "test.jsp", b"<% out.println('hacked'); %>"), # 后缀名检测
            ("Path_Traversal", "../../../test.txt", b"content"),             # 路径穿越
            ("Null_Content", "empty.txt", b"")                               # 空文件拒绝服务
        ]
        for name, filename, content in vectors:
            files = {'file': (filename, content, 'application/octet-stream')}
            try:
                resp = requests.request(method, url, headers=headers, files=files)
                if resp.status_code == 500: # 重点关注 500
                    fuzz_results.append({"type": name, "code": 500, "msg": "上传导致崩溃"})
            except Exception as e:
                pass

    # 3. 针对 JSON 的 Fuzz 策略 (基于 Smart Payload)
    else:
        # 遍历 Smart Payload 中的字段进行变异
        for key, value in base_payload.items():
            # 构造变异体 (深拷贝)
            mutated = base_payload.copy()
            mutated[key] = "' OR '1'='1" # SQLi 探测
            
            headers['Content-Type'] = 'application/json'
            try:
                resp = requests.request(method, url, headers=headers, json=mutated)
                # 记录 500 错误或包含 SQLSyntax 报错的响应
                if resp.status_code == 500:
                    fuzz_results.append({"type": f"SQLi_Fuzz_{key}", "code": 500, "msg": "参数变异导致崩溃"})
            except Exception as e:
                pass
                
    return fuzz_results
```


- [ ] 动态载荷填充：基于 API 定义的参数类型进行 intelligent_fuzz，在合法载荷的基础上注入 Payload，降低由于格式错误导致的误报。

- [ ] 载荷继承 (Smart Seed): 不再凭空生成 Payload，而是读取 apis.json 中的 smart_payload (即我们提取到的 DTO 结构) 作为种子，在此基础上修改，确保不会因为缺字段直接 NPE。

- [ ] **安全前置检查 (Admin Shield)**
   - 严禁对 URL 结尾为 `/1`, `/0`, `/admin` 的接口执行 Fuzz。
   - 严禁向包含 `admin`, `system` 关键词的数据注入 SQL 载荷。

- [ ] 文件上传 Fuzz:

   - 文件名攻击: 测试 ../../../etc/passwd, shell.jsp, test.exe。

   - 空文件攻击: 上传 0 字节文件。

- [ ] JSON Fuzz:

   - 类型突变: 将 int 字段改为 string，将 boolean 改为 int。

   - SQL/XSS 注入探测: 在字符串字段注入 ' OR 1=1 -- 或 <script>alert(1)</script>。
   
- [ ] 熔断机制：针对 DELETE 和 DROP 关键字接口强制跳过 Fuzzing，防止误删生产或测试数据。

- [ ] 异常识别：判定 biz_code == 500 且包含堆栈信息为失败。

- [ ] **多态 Fuzz 逻辑**
   - **Upload 场景**: 构造恶意文件名 (`test.jsp`, `../../config`) 和空文件。
   - **JSON 场景**: 注入 SQL 字符 (`' OR 1=1`) 和超大整数。



切换至debugger模式
- [ ] 流程自检：若认证凭据比如token失效，则需要通过运行前置token获取脚本重新获取
- [ ] 数据审查：检查测试过程中是否因载荷格式错误导致过多的 JSON_PARSE_FAIL，优化载荷生成逻辑。
- [ ] 脱敏处理：确保日志中所有 Token 均替换为 <REDACTED>。

## 输出：写入 {work_dir}/results_fuzzing.json。
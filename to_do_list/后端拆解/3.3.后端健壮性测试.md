# 健壮性模糊测试 (step2_3_fuzz.py)

切换至script engineer模式
- [ ] 创建 step2_3_fuzz.py

## Python 核心逻辑示例
```python
import requests, re, random, json

# 辅助函数：动态填充路径参数
def fill_path_params(url, id_pool):
    matches = re.findall(r'\{(.*?)\}', url)
    for param in matches:
        valid_values = []
        for k, v in id_pool.items():
            if param.lower() in k.lower():
                valid_values = v
                break
        
        if valid_values:
            val = random.choice(valid_values)
            url = url.replace(f"{{{param}}}", str(val))
        else:
            url = url.replace(f"{{{param}}}", "1")
    return url

def run_polymorphic_fuzz(base_url, token, api_list):
    headers = {"Authorization": f"Bearer {token}"}
    fuzz_results = []
    
    # 1. 提取全局 ID 池
    global_id_pool = {}
    for api in api_list:
        if 'id_pool' in api and api['id_pool']: 
            global_id_pool.update(api['id_pool'])

    for api in api_list:
        method = api['method']
        
        # 2. 熔断机制：跳过 DELETE 和 Drop 操作
        if method == 'DELETE' or 'drop' in api['path'].lower(): continue

        # 3. 准备基础数据
        raw_url = f"{base_url}{api['path']}"
        url = fill_path_params(raw_url, global_id_pool) # 动态填充
        
        # 4. Admin Shield: 填充后检查是否指向管理员
        if any(x in url for x in ['/1', '/0', '/admin']): continue

        # 5. 载荷继承 (关键): 使用审查过的 Payload 作为种子
        base_payload = api.get('smart_payload', {})
        
        # === 场景 A: Upload Fuzz ===
        if api.get('content_type') == 'multipart/form-data':
            vectors = [
                ("Malicious_Ext", "test.jsp", b"<% out.println('hacked'); %>"),
                ("Null_Content", "empty.txt", b"")
            ]
            for name, fname, content in vectors:
                files = {'file': (fname, content, 'application/octet-stream')}
                try:
                    resp = requests.request(method, url, headers=headers, files=files)
                    if resp.status_code == 500:
                        fuzz_results.append({"type": name, "path": api['path'], "code": 500, "msg": "文件上传Fuzz导致崩溃"})
                except: pass

        # === 场景 B: JSON Fuzz ===
        else:
            # 针对每个字段进行变异，其他字段保持合法
            for key, value in base_payload.items():
                mutated = base_payload.copy()
                
                # 注入 SQLi
                mutated[key] = "' OR '1'='1"
                try:
                    resp = requests.request(method, url, headers=headers, json=mutated)
                    if resp.status_code == 500:
                        fuzz_results.append({"type": f"SQLi_{key}", "path": api['path'], "code": 500, "msg": "SQL注入导致崩溃"})
                except: pass
                
                # 注入 超大整数 (针对 int 字段)
                if isinstance(value, int):
                    mutated[key] = 99999999999
                    try:
                        resp = requests.request(method, url, headers=headers, json=mutated)
                        if resp.status_code == 500:
                            fuzz_results.append({"type": f"Overflow_{key}", "path": api['path'], "code": 500, "msg": "整数溢出导致崩溃"})
                    except: pass

    return fuzz_results
```

## 核心逻辑与安全约束：
- 数据源加载：读取 apis.json，必须使用其中经过基准测试更新过的 smart_payload 作为 Fuzz 种子。

- 路径有效性：使用 id_pool 填充路径参数，确保 Fuzz 请求能到达业务代码。

- Admin Shield：严禁对 URL 结尾为 /1, /0, /admin 的接口执行 Fuzz。

- 熔断机制：针对 DELETE 方法接口，强制跳过。

- 异常识别：判定 biz_code == 500 或 HTTP 500 且包含堆栈信息为失败。

- 输出：写入 {work_dir}/results_fuzzing.json。
## 切换至debugger模式

- [ ] 流程自检：Token 失效重连、日志脱敏。
# ğŸŸ¢ ä»»åŠ¡ä¸€ï¼šå¤šè¯­è¨€ API æå– (step1_extract.py)

## ğŸ“ å¾…æ‰§è¡ŒæŒ‡ä»¤ï¼š
- [ ] ç¡®è®¤æŠ€æœ¯æ ˆï¼ˆJava/Spring Bootï¼‰
- [ ] åˆ›å»º `step1_extract.py`ï¼Œå†™å…¥ä»¥ä¸‹å…¨é‡ä»£ç ã€‚
- [ ] **æ ¸å¿ƒå‡çº§**ï¼šåŒ…å«å®Œæ•´çš„ DTO é€’å½’è§£æå™¨å’Œåˆ†ç»„é€»è¾‘ã€‚

## ğŸ› ï¸ åˆ‡æ¢è‡³ [Script Engineer æ¨¡å¼]

```python
# -*- coding: utf-8 -*-
import os, re, json, sys, io
from collections import defaultdict

def setup_encoding():
    if sys.platform == "win32":
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8", errors="replace")
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding="utf-8", errors="replace")

# --- 1. DTO è§£æå™¨ ---
def parse_class_fields(root_dir, class_name, recursion_depth=0):
    if recursion_depth > 3: return {}
    if class_name in ["String", "Integer", "Long", "Double", "Boolean", "MultipartFile", "List", "Map", "Object"]:
        return {} 

    fields = {}
    target_file = None
    for root, _, files in os.walk(root_dir):
        if f"{class_name}.java" in files:
            target_file = os.path.join(root, f"{class_name}.java")
            break
            
    if target_file:
        try:
            with open(target_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                # ç»§æ‰¿
                parent_match = re.search(r'class\s+\w+\s+extends\s+(\w+)', content)
                if parent_match:
                    fields.update(parse_class_fields(root_dir, parent_match.group(1), recursion_depth + 1))
                # å­—æ®µ
                matches = re.findall(r'private\s+(?!static)(?:final\s+)?(\w+(?:<.+>)?)\s+(\w+)\s*(?:=.*?)?;', content)
                for f_type, f_name in matches:
                    if "String" in f_type: 
                        if "email" in f_name.lower(): fields[f_name] = "test@example.com"
                        elif "status" in f_name.lower(): fields[f_name] = "0"
                        if f_name == "params":
                            fields[f_name] = {}
                        else: fields[f_name] = f"test_{f_name}"
                    elif f_type in ["Integer", "int", "Long", "long"]: 
                        if "id" in f_name.lower(): fields[f_name] = None 
                        else: fields[f_name] = 0
                    elif "List" in f_type: fields[f_name] = []
        except: pass
    return fields

# --- 2. æå–é€»è¾‘ ---
def extract_java_apis(source_root):
    apis = []
    method_block_re = re.compile(r'@(Get|Post|Put|Delete)Mapping.*?(?:public|protected).*?\(.*?\)', re.DOTALL)
    mapping_path_re = re.compile(r'Mapping(?:\((?:value\s*=\s*)?"?([^")]*)"?\))?')
    params_re = re.compile(r'\((.*?)\)$', re.DOTALL)
    class_re = re.compile(r'@RequestMapping\("?([^"]*)"?\)')

    for root, _, files in os.walk(source_root):
        for file in files:
            if not file.endswith(".java") or "Controller" not in file: continue
            
            with open(os.path.join(root, file), 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                class_matches = class_re.findall(content)
                base_path = class_matches[0].strip("/") if class_matches else ""
                if not base_path: continue

                for match in method_block_re.finditer(content):
                    block = match.group()
                    m_type = re.search(r'@(Get|Post|Put|Delete)Mapping', block).group(1).upper()
                    
                    path_match = mapping_path_re.search(block)
                    sub_path = path_match.group(1).strip("/") if (path_match and path_match.group(1)) else ""
                    full_path = f"/{base_path}/{sub_path}".replace("//", "/") if sub_path else f"/{base_path}"
                    
                    param_match = params_re.search(block)
                    m_params = param_match.group(1) if param_match else ""
                    
                    smart_payload = {}
                    if "@RequestBody" in m_params:
                        try:
                            parts = m_params.split("@RequestBody")[1].strip().split()
                            for part in parts:
                                if part.startswith("@"): continue
                                smart_payload = parse_class_fields(source_root, part)
                                break
                        except: pass
                    
                    apis.append({"path": full_path, "method": m_type, "smart_payload": smart_payload})
    return apis

# --- 3. ç­›é€‰å™¨ (Top 8) ---
def filter_high_value_apis(apis):
    groups = defaultdict(list)
    for api in apis:
        path = api['path']
        base = re.sub(r'/\{.*?\}', '', path)
        base = re.sub(r'/(list|export|import|sort|clean|authRole|resetPwd|changeStatus|profile).*', '', base)
        groups[base].append(api)

    perfect_groups = []
    for base, items in groups.items():
        methods = set(item['method'] for item in items)
        if 'GET' in methods and 'POST' in methods:
            score = 100 if any(kw in base for kw in ['user', 'dept', 'role', 'post', 'config', 'dict', 'menu', 'notice']) else 50
            if 'DELETE' in methods: score += 20
            perfect_groups.append({"base": base, "score": score, "items": items})
    
    perfect_groups.sort(key=lambda x: x["score"], reverse=True)
    final_list = []
    
    print(f"[FILTER] ç­›é€‰å‡º {len(perfect_groups)} ä¸ªæ ¸å¿ƒç»„ï¼Œä¿ç•™ Top 8")
    for group in perfect_groups[:8]:
        final_list.extend(group['items'])
            
    return final_list

def main():
    setup_encoding()
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(os.path.dirname(script_dir))
    config_path = os.path.join(project_root, "configure.json")
    work_dir = os.path.join(project_root, "å·¥ä½œåŒº")
    
    with open(config_path, "r", encoding="utf-8") as f:
        config_data = json.load(f)
    
    source_path = config_data["project_setup"]["source_code_path"]
    apis = extract_java_apis(source_path)
    final_apis = filter_high_value_apis(apis)
    
    output = { "total_extracted": len(apis), "final_selected": len(final_apis), "apis": final_apis }
    
    with open(os.path.join(work_dir, "apis.json"), "w", encoding="utf-8") as f:
        json.dump(output, f, indent=2, ensure_ascii=False)
    return True

if __name__ == "__main__":
    main()
```

## ğŸ åˆ‡æ¢è‡³ [Debugger æ¨¡å¼]
- [ ] æ‰§è¡Œè„šæœ¬ã€‚

- [ ] éªŒè¯: æ‰“å¼€ apis.jsonï¼Œæ£€æŸ¥ POST æ¥å£çš„ smart_payload æ˜¯å¦åŒ…å« userName, nickName ç­‰å­—æ®µï¼Œç¡®è®¤ä¸å†ä¸ºç©ºã€‚
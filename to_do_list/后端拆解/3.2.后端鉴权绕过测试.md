# 越权/鉴权绕过测试 (step2_2_auth.py)
切换至script engineer模式
- [ ] 创建 step2_2_auth.py

## Python 核心逻辑示例
```python
import requests

def run_auth_bypass(base_url, api_list):
    results = []
    # 遍历所有接口
    for api in api_list:
        method = api['method']
        url = f"{base_url}{api['path']}"
        
        # === 安全防御 (Admin Shield) ===
        # 1. 针对高危方法 (DELETE/PUT)，如果 URL 涉及敏感 ID，直接跳过
        if method in ['DELETE', 'PUT']:
            if any(x in url for x in ['/1', '/0', '/admin', '/root']):
                print(f"🛡️ [Shield] 跳过敏感资源的越权测试: {url}")
                continue
        
        # 2. 构造无鉴权请求
        # 不传 Authorization 头，或者传脏数据
        headers = {"Authorization": "Bearer invalid_token_test"}
        
        # 使用 Payload (尽量使用 GET 挖掘到的真实 Payload，如果没有则为空)
        # 注意：这里我们只测鉴权层，参数校验层报错不影响鉴权结果
        payload = api.get('smart_payload', {})

        try:
            if method == 'GET':
                resp = requests.get(url, headers=headers, params=payload)
            elif method == 'POST':
                resp = requests.post(url, headers=headers, json=payload)
            elif method == 'PUT':
                resp = requests.put(url, headers=headers, json=payload)
            elif method == 'DELETE':
                resp = requests.delete(url, headers=headers)
            
            # === 判定标准 ===
            # 安全：401 Unauthorized / 403 Forbidden
            # 漏洞：200 OK 且返回了有效数据 (biz_code=200)
            is_vuln = False
            if resp.status_code == 200:
                # 进一步检查业务码
                try:
                    data = resp.json()
                    if data.get('code') == 200: 
                        is_vuln = True
                except:
                    # 非 JSON 的 200 也算疑似漏洞
                    is_vuln = True
            
            if is_vuln:
                results.append({
                    "type": "no_auth",
                    "path": api['path'],
                    "method": method,
                    "code": 200, 
                    "msg": "🔴 越权漏洞: 未鉴权访问成功"
                })
            else:
                # 记录 Pass (用于统计覆盖率)
                pass 

        except Exception as e:
            pass
            
    return results
```
- [ ] 请求构造：使用对应的 API 定义中的有效载荷发送请求，以确保请求能够到达业务鉴权逻辑层而非被前端校验拦截。

## 核心逻辑：

- 安全防御 (Admin Shield)：

   - 对于 DELETE 和 PUT 接口，若 URL 包含 /1、/0 或 /admin，强制跳过测试，防止因鉴权缺失导致管理员数据被误删/误改。

- 核心检测：不携带 Token 或使用 伪造/过期 Token 发送请求。

- 判定标准：

   - HTTP 401/403 或 biz_code != 200 -> 安全 (Pass)。

   - HTTP 200 且 biz_code == 200 -> 高危漏洞 (Fail)。

## 输出：写入 {work_dir}/results_auth_bypass.json。

切换至debugger模式
- [ ] 流程自检：若认证凭据比如token失效，则需要通过运行前置token获取脚本重新获取
- [ ] 数据审查：检查测试过程中是否因载荷格式错误导致过多的 JSON_PARSE_FAIL，优化载荷生成逻辑。
- [ ] 脱敏处理：确保日志中所有 Token 均替换为 <REDACTED>。
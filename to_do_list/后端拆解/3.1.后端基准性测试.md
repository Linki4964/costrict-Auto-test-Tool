# 基准功能测试 (step2_1_baseline.py)
切换至script engineer模式
- [ ] 创建 step2_1_baseline.py

   - Python 逻辑示例
```python

import requests, time, re

# 1. 动态唯一化 Payload (解决重复键冲突)
def enrich_payload(payload):
    new_payload = payload.copy()
    suffix = str(int(time.time()))
    for k, v in new_payload.items():
        # 对 name, code, key, title 等关键字段追加时间戳
        if isinstance(v, str) and any(x in k.lower() for x in ['name', 'code', 'key', 'title']):
            new_payload[k] = f"{v}_{suffix}"
    return new_payload

# 2. 管理员保护盾 (Admin Shield)
def is_protected_resource(url, method, payload=None):
    # 拦截针对 ID=1, 0 或 admin 的破坏性操作
    if method in ['DELETE', 'PUT']:
        # 检查 URL 结尾是否包含敏感 ID
        if re.search(r'/(1|0|admin|system)$', url): return True
        # 检查 Payload 是否包含敏感关键词
        if payload and 'admin' in str(payload).lower(): return True
    return False

def run_lifecycle_test(base_url, token, api_config):
    url = f"{base_url}{api_config['path']}"
    method = api_config['method']
    headers = {"Authorization": f"Bearer {token}"}
    
    # A. 针对 POST 请求：动态唯一化
    if method == 'POST' and api_config.get('content_type') == 'application/json':
        final_payload = enrich_payload(api_config.get('payload', {}))
    else:
        final_payload = api_config.get('payload', {})

    # B. 针对 DELETE/PUT 请求：管理员保护
    if is_protected_resource(url, method, final_payload):
        return {"code": 0, "msg": "SKIPPED_SAFE: 触发管理员保护盾"}

    # C. 发送请求 (含 Upload/Download 自适应)
    try:
        if api_config.get('content_type') == 'multipart/form-data':
            files = {'file': ('test.txt', b'AI Test Content', 'text/plain')}
            resp = requests.request(method, url, headers=headers, files=files)
        else:
            headers['Content-Type'] = 'application/json'
            resp = requests.request(method, url, headers=headers, json=final_payload)
            
        # D. 生命周期闭环 (关键新增)
        # 如果是 POST 且成功，返回 ID 供后续 DELETE 使用
        if method == 'POST' and resp.status_code == 200:
            try:
                data = resp.json()
                created_id = data.get('data', {}).get('id') or data.get('id')
                if created_id:
                    return {"code": 200, "msg": "创建成功", "created_id": created_id}
            except: pass
            
        # E. 响应处理 (跳过二进制流)
        resp_type = resp.headers.get('Content-Type', '')
        if any(t in resp_type for t in ['stream', 'excel', 'pdf', 'image']):
             return {"code": 200, "msg": "文件流下载成功 (Blob)"}
             
        return resp.json()

    except Exception as e:
        return {"code": 500, "msg": f"请求异常: {str(e)}"}
```

- [ ] 读取 {work_dir}/apis.json 并获取目标 Base URL 与认证凭据（若认证凭据比如token失效，则需要通过运行脚本重新获取）
- [ ] 读取 {work_dir}/apis.json 获取目标信息。

- [ ] 核心实现：生命周期闭环

    - 动态唯一性：POST 请求必须对 name/code 字段追加时间戳。

    - Admin Shield：DELETE/PUT 请求前必须检查 URL 或 ID，若是 1/0/admin 则跳过。

    - 先增后删：若 POST 成功并提取到 ID，立即记录日志 CREATED_ID: {id}。
## 核心逻辑：

- 携带有效 Token 发送标准请求
  - 请求自适应：读取 apis.json 中的 content_type 字段。

     - 若是 multipart/form-data：构造 files 参数进行上传测试。

     - 若是 application/json：使用提取到的 Smart Payload。

  - 响应自适应：检查响应头 Content-Type。

     - 若是二进制流（如 application/octet-stream, application/vnd.ms-excel）：只要状态码是 200 即判定成功，不尝试解析 JSON（避免 "响应不是有效的JSON格式" 报错）。

- 尽量使用对应的 API 中定义的有效载荷去发送请求，否则容易产生脏数据或错误
- 实现 parse_response 逻辑：判定 biz_code == 200 为通过
- 记录 biz_msg 作为功能正常的证据
---
切换至debugger模式
- [ ] 流程自检：若认证凭据比如token失效，则需要通过运行前置token获取脚本重新获取

- [ ] 数据审查：检查测试过程中是否因载荷格式错误导致过多的 JSON_PARSE_FAIL，优化载荷生成逻辑。

- [ ] 脱敏处理：确保日志中所有 Token 均替换为 <REDACTED>。

## 输出：写入 {work_dir}/results_baseline.json


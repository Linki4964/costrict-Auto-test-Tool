# 基准与生命周期闭环测试 (step2_1_baseline.py)

切换至script engineer模式
- [ ] 创建 step2_1_baseline.py

## Python 核心逻辑示例 (引入动态学习机制)
```python
import requests, time, re, json, random

# 1. 全局知识库
resource_templates = {}  # 路径 -> Payload 模板
id_pool = {}            # 参数名 -> [有效值列表] (e.g., "userId": [101, 102])

# 2. 阶段一：数据挖掘 (执行 GET 接口)
def mine_real_data(base_url, token, api_list):
    print("⛏️ [Mining] 正在挖掘真实数据...")
    headers = {"Authorization": f"Bearer {token}"}
    
    for api in api_list:
        if api['method'] != 'GET': continue
        
        try:
            # 尝试获取列表数据
            resp = requests.get(f"{base_url}{api['path']}", headers=headers, params={"pageNum": 1, "pageSize": 5})
            if resp.status_code == 200:
                data = resp.json()
                rows = data.get('rows') or data.get('data') or []
                
                if isinstance(rows, list) and len(rows) > 0:
                    # A. 学习 Payload 模板
                    template = rows[0]
                    resource_key = api['path'].replace("/list", "")
                    resource_templates[resource_key] = template
                    
                    # B. 学习有效 ID (构建 ID 池)
                    for item in rows:
                        for k, v in item.items():
                            # 收集所有可能是 ID 的字段 (userId, roleId, deptId...)
                            if k.lower().endswith("id") and v:
                                if k not in id_pool: id_pool[k] = []
                                if v not in id_pool[k]: id_pool[k].append(v)
                                
                    print(f"✅ [Learned] {api['path']} -> Template & IDs gathered")
        except:
            pass

# 3. 辅助：路径参数填充
def fill_path_params(url):
    # 查找 URL 中的 {xxx}
    matches = re.findall(r'\{(.*?)\}', url)
    for param_name in matches:
        # 尝试从 ID 池中找
        # 策略：优先找完全匹配 (userId)，其次找模糊匹配
        valid_values = id_pool.get(param_name)
        if not valid_values:
            # 尝试模糊匹配 (e.g. param="id" -> try "userId", "roleId")
            for pool_key, vals in id_pool.items():
                if param_name.lower() in pool_key.lower():
                    valid_values = vals
                    break
        
        if valid_values:
            val = random.choice(valid_values)
            url = url.replace(f"{{{param_name}}}", str(val))
        else:
            # 如果真的找不到，填一个默认值避免 URL 格式错误，但可能会 404
            url = url.replace(f"{{{param_name}}}", "1")
    return url

# 4. 阶段二：智能 Payload 生成
def generate_smart_payload(api, original_payload):
    method = api['method']
    resource_key = api['path']
    template = resource_templates.get(resource_key)
    
    # 如果没有学习到模板，使用原始静态分析的 Payload
    final_payload = template.copy() if template else original_payload.copy()
    if not final_payload: return {}

    timestamp = str(int(time.time()))

    # === 针对不同方法的策略 ===
    
    # 策略 A: POST (新增) -> 清理 ID，重命名
    if method == 'POST':
        for key in list(final_payload.keys()):
            # 这里的 ID 判空逻辑：通常 POST 不需要 ID
            # 但如果后端报错 "ID不能为空"，说明这可能是一个伪装成 POST 的 Update
            # 或者后端使用了非自增 ID。此处保持置空，依赖后端生成。
            if key in ['id', 'userId', 'roleId', 'deptId']:
                final_payload[key] = None 
        
        # 唯一化
        for k, v in final_payload.items():
            if isinstance(v, str) and 'admin' in v.lower():
                final_payload[k] = f"auto_{timestamp}"
    
    # 策略 B: PUT (修改) -> 【关键修复】保留 ID
    elif method == 'PUT':
        # PUT 必须带 ID，否则后端不知道改谁
        # 如果模板里有 ID，直接保留，不要置空！
        pass 

    return final_payload

# 5. 阶段三：执行测试
def run_lifecycle_test(base_url, token, api_list):
    mine_real_data(base_url, token, api_list)
    results = []
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

    for api in api_list:
        method = api['method']
        if method not in ['POST', 'PUT', 'DELETE']: continue
        
        # 1. 处理 URL (填充路径参数)
        url = fill_path_params(f"{base_url}{api['path']}")
        
        # 2. 准备 Payload
        payload = {}
        if method in ['POST', 'PUT']:
            payload = generate_smart_payload(api, api.get('smart_payload', {}))

        try:
            # 安全检查
            if method == 'DELETE' and (url.endswith("/1") or url.endswith("/0")):
                print(f"🚫 [Skip] 跳过删除 Admin ID: {url}")
                continue

            if method == 'DELETE':
                resp = requests.delete(url, headers=headers)
            elif method == 'POST':
                resp = requests.post(url, headers=headers, json=payload)
            elif method == 'PUT':
                resp = requests.put(url, headers=headers, json=payload)
                
            results.append({"path": api['path'], "method": method, "code": resp.status_code})
            
        except Exception as e:
            results.append({"path": api['path'], "method": method, "code": 500, "msg": str(e)})

    return results
```

- [ ] 读取 {work_dir}/apis.json 并获取目标 Base URL 与认证凭据（若认证凭据比如token失效，则需要通过运行脚本重新获取）
## 核心逻辑：
- 修复 ID 判空问题：

  - 在 generate_smart_payload 中增加了对 PUT 方法的判断。当方法为 PUT 时，不再清空 ID 字段，直接复用从 GET 接口学到的真实 ID。这解决了修改接口因缺 ID 报错的问题。

  - 对于 POST 接口，依然保持清空 ID（遵循新建逻辑）。

- 修复路径参数缺失：

  - 新增 fill_path_params 函数。

  - 在数据挖掘阶段，建立了 id_pool（ID 池），收集系统里所有有效的 ID（如 userId=101）。

  - 在请求前，自动将 URL 中的 {userId} 替换为 ID 池中的有效值。
- 携带有效 Token 发送标准请求
  - 请求自适应：读取 apis.json 中的 content_type 字段。

     - 若是 multipart/form-data：构造 files 参数进行上传测试。

     - 若是 application/json：使用提取到的 Smart Payload。

  - 响应自适应：检查响应头 Content-Type。

     - 若是二进制流（如 application/octet-stream, application/vnd.ms-excel）：只要状态码是 200 即判定成功，不尝试解析 JSON（避免 "响应不是有效的JSON格式" 报错）。

- 尽量使用对应的 API 中定义的有效载荷去发送请求，否则容易产生脏数据或错误
- 实现 parse_response 逻辑：判定 biz_code == 200 为通过
- 记录 biz_msg 作为功能正常的证据

## 待执行指令
- [ ] 读取 {work_dir}/apis.json 获取目标信息。

- [ ] Step 1: 逆向学习 (Reverse Learning)

   - 遍历所有 GET 类型接口（特别是 /list 结尾的）。

   - 发送请求并解析响应中的 rows 或 data 数组。

   - 提取第一条有效数据（即使是 Admin 数据）作为该模块的“黄金模板 (Golden Template)”。

- [ ] Step 2: 载荷重构 (Payload Reconstruction)

   - 将学习到的模板写入内存映射。

   - 针对 POST 接口，基于模板生成 Payload，但必须执行脱敏与唯一化：

   - 置空 ID：确保后端识别为“新增”操作。

   - 重命名：将 admin 改为 auto_test，将 name 字段追加时间戳。

- [ ] Step 3: 动态参数填充

   - 在发起请求前，检查 URL 是否包含 {} 占位符。

   - 从 id_pool 中寻找匹配的 ID 进行替换（如 {userId} -> 102）。

- [ ] Step 4: 区分方法的 Payload 生成

   - POST: 清空 ID，重命名 Name (防冲突)。

   - PUT: 保留 ID (确保能定位到修改对象)，仅修改非关键字段（可选）。

- [ ] Step 5: 增删闭环 (Create-Delete Loop)

   - 使用重构后的 Payload 发送 POST 请求。

   - 若成功 (200)，提取返回的 new_id。

   - 立即构造 DELETE 请求清理该 ID（严禁删除 ID=1/admin）。

- [ ] 输出：写入 {work_dir}/results_baseline.json，并将学习到的高质量 Payload 更新回 {work_dir}/apis.json 以供后续 Fuzz 测试使用。

## 切换至debugger模式

- [ ] 流程自检：Token 失效重连、日志脱敏。确认 PUT 、DELETE请求的 Payload 中包含了 ID，确认路径参数已被替换为具体数值。
# 基准功能测试 (step2_1_baseline.py)
切换至script engineer模式
- [ ] 创建 step2_1_baseline.py

   - Python 逻辑示例
```python
import requests

def send_adaptive_request(base_url, token, api_config):
    url = f"{base_url}{api_config['path']}"
    method = api_config['method']
    headers = {"Authorization": f"Bearer {token}"}
    
    try:
        # A. 请求构造阶段
        if api_config.get('content_type') == 'multipart/form-data':
            # 构造伪造文件流
            files = {'file': ('test_upload.txt', b'AI Automated Test Content', 'text/plain')}
            # 注意：使用 files 时不要手动设置 Content-Type header，requests 会自动处理 boundary
            resp = requests.request(method, url, headers=headers, files=files)
        else:
            # 标准 JSON 请求
            headers['Content-Type'] = 'application/json'
            resp = requests.request(method, url, headers=headers, json=api_config.get('payload', {}))

        # B. 响应处理阶段
        # 1. 检查是否为下载/导出类接口 (Blob)
        resp_type = resp.headers.get('Content-Type', '')
        if any(t in resp_type for t in ['stream', 'excel', 'pdf', 'image', 'download']):
            if resp.status_code == 200:
                return {"code": 200, "msg": "文件流下载成功 (Blob)", "data": "BINARY_DATA_SKIPPED"}
            else:
                return {"code": resp.status_code, "msg": f"文件流下载失败: {resp.status_code}"}

        # 2. 标准 JSON 响应
        return resp.json()

    except Exception as e:
        return {"code": 500, "msg": f"请求异常: {str(e)}"}
```

- [ ] 读取 {work_dir}/apis.json 并获取目标 Base URL 与认证凭据（若认证凭据比如token失效，则需要通过运行脚本重新获取）

## 核心逻辑：

- 携带有效 Token 发送标准请求
  - 请求自适应：读取 apis.json 中的 content_type 字段。

     - 若是 multipart/form-data：构造 files 参数进行上传测试。

     - 若是 application/json：使用提取到的 Smart Payload。

  - 响应自适应：检查响应头 Content-Type。

     - 若是二进制流（如 application/octet-stream, application/vnd.ms-excel）：只要状态码是 200 即判定成功，不尝试解析 JSON（避免 "响应不是有效的JSON格式" 报错）。

- 尽量使用对应的 API 中定义的有效载荷去发送请求，否则容易产生脏数据或错误
- 实现 parse_response 逻辑：判定 biz_code == 200 为通过
- 记录 biz_msg 作为功能正常的证据
---
## 输出：写入 {work_dir}/results_baseline.json

切换至debugger模式
- [ ] 流程自检：若认证凭据比如token失效，则需要通过运行前置token获取脚本重新获取

- [ ] 数据审查：检查测试过程中是否因载荷格式错误导致过多的 JSON_PARSE_FAIL，优化载荷生成逻辑。

- [ ] 脱敏处理：确保日志中所有 Token 均替换为 <REDACTED>。